#!/usr/bin/env python

"Script for plotting functional values for all result directories"

__author__ = "Kristoffer Selim and Anders Logg"
__copyright__ = "Copyright (C) 2010 Simula Research Laboratory and %s" % __author__
__license__  = "GNU GPL Version 3 or any later version"

import os, glob, sys
from numpy import argsort, array
from pylab import *

# Get command-line parameters
cases = ("M", "e", "E", "Eh", "Ek", "Ec", "EcF", "EcS", "EcM", "I", "Ih", "Ik", "Ic")
if len(sys.argv) != 2 or not sys.argv[1] in cases:
    print "Usage: plot <variable>"
    print "where <variable> is one of %s" % ", ".join(cases)
    sys.exit(1)
variable = sys.argv[1]

# Set reference value
reference_value = 0.00363978

def read(filename):
    return zip(*[[x for x in row.split(" ") if len(x) >0] for row in open(filename).read().split("\n") if " " in row and len(row) > 0])

def read_float(filename):
    return array([[float(x) for x in column] for column in read(filename)])

# Check all results directories
D   = []
M   = []
ETA = []
E   = []
Eh  = []
Ek  = []
Ec  = []
EcF = []
EcS = []
EcM = []
I   = []
Ih  = []
Ik  = []
Ic  = []
L   = []
for directory in glob.glob("results-*"):
    print "Extracting values from %s" % directory

    # Check for data
    if not os.path.isfile("%s/goal_functional_final.txt" % directory):
        continue

    # Get number of dofs
    filename = "%s/num_dofs.txt" % directory
    if os.path.isfile(filename):
        d = read_float(filename)[2]
        D.append(d)
    else:
        D.append(None)

    # Get functional values
    filename = "%s/goal_functional_final.txt" % directory
    if os.path.isfile(filename):
        m = read_float(filename)[2]
        M.append(m)
        eta = abs(m - reference_value)
        ETA.append(abs(m - reference_value))
    else:
        M.append(None)
        ETA.append(None)

    # Get error estimates
    filename = "%s/error_estimates.txt" % directory
    if os.path.isfile(filename):
        e, eh, ek, ec, ecf, ecs, ecm = read_float(filename)[1:8]
        E.append(e)
        Eh.append(eh)
        Ek.append(ek)
        Ec.append(ec)
        EcF.append(abs(ecf))
        EcS.append(abs(ecs))
        EcM.append(abs(ecm))
    else:
        E.append(None)
        Eh.append(None)
        Ek.append(None)
        Ec.append(None)
        EcF.append(None)
        EcS.append(None)
        EcM.append(None)

    # Compute efficiency index
    n = min(len(e), len(eta))
    i = e[:n] / eta[:n]
    ih = eh[:n] / eta[:n]
    ik = ek[:n] / eta[:n]
    ic = ec[:n] / eta[:n]
    I.append(i)
    Ih.append(ih)
    Ik.append(ik)
    Ic.append(ic)

    # Get legend
    filename = "%s/application_parameters.xml" % directory
    row = [row for row in open(filename).read().split("\n") if "description" in row][0]
    l = row.split('value="')[1].split('"')[0]
    L.append(l)

    print "Found %d values" % len(d)

# Select variable to plot
X = D
if variable == "M":
    Y = M
    _title  = "Convergence of goal functional"
    _ylabel = "$\mathcal{M}(u_h)$"
    _plot   = semilogx
elif variable == "e":
    Y = ETA
    _title  = "Error in goal functional"
    _ylabel = "$\eta = |\mathcal{M}(u_h) - \mathcal{M}(u)|$"
    _plot   = loglog
elif variable == "E":
    Y = E
    _title  = "Error estimate (total)"
    _ylabel = "$E$"
    _plot   = loglog
elif variable == "Eh":
    Y = Eh
    _title  = "Space discretization error"
    _ylabel = "$E_h$"
    _plot   = loglog
elif variable == "Ek":
    Y = Ek
    _title  = "Time discretization error"
    _ylabel = "$E_k$"
    _plot   = loglog
elif variable == "Ec":
    Y = Ec
    _title  = "Computational error"
    _ylabel = "$E_c$"
    _plot   = loglog
elif variable == "EcF":
    Y = EcF
    _title  = "Fluid computational error"
    _ylabel = "$E_c^F$"
    _plot   = loglog
elif variable == "EcS":
    Y = EcS
    _title  = "Structure computational error"
    _ylabel = "$E_c^S$"
    _plot   = loglog
elif variable == "EcM":
    Y = EcM
    _title  = "Mesh computational error"
    _ylabel = "$E_c^M$"
    _plot   = loglog
elif variable == "I":
    Y = I
    _title  = "Efficiency index (total)"
    _ylabel = "$E / \eta$"
    #_plot   = semilogx
    _plot   = loglog
elif variable == "Ih":
    Y = Ih
    _title  = "Efficiency index ($I_h$)"
    _ylabel = "$E_h / \eta$"
    #_plot   = semilogx
    _plot   = loglog
elif variable == "Ik":
    Y = Ik
    _title  = "Efficiency index ($I_k$)"
    _ylabel = "$E_k / \eta$"
    #_plot   = semilogx
    _plot   = loglog
elif variable == "Ic":
    Y = Ic
    _title  = "Efficiency index ($I_c$)"
    _ylabel = "$E_c / \eta$"
    #_plot   = semilogx
    _plot   = loglog

# Sort values by legend

print len(X), len(Y)
indices = argsort(L)[:min(len(L), len(X))]
L = [L[i] for i in indices]

 # Group values
plotvals = []
for i in indices:
    x = X[i]
    y = Y[i]
    if x is None or y is None:
        print "Warning: missing values for %s, skipping" % variable
        x = [1]
        y = [1]
    if len(y) < len(x):
        print "Warning: missing values for %s (only %d, expecting %d)" % (variable, len(y), len(x))
        x = x[:len(y)]
    plotvals.append(x)
    plotvals.append(y)

# Set fontsize for legend
rcParams.update({'legend.fontsize': 9})

# Plot functional values
max_plots = 13
for i in range((len(L) - 1) / max_plots + 1):

    if i != 2:
        continue

    figure(i)
    subplot(2, 1, 1)
    xy = plotvals[2*i*max_plots:2*(i + 1)*max_plots]
    _plot(*xy, marker='o')
    grid(True)
    xlabel("Number of dofs (in space)")
    ylabel(_ylabel)
    title(_title)
    legend(L[i*max_plots:(i + 1)*max_plots], bbox_to_anchor=(-0.1, -0.3), loc=2, borderaxespad=0)

show()
