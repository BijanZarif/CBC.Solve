#!/usr/bin/env python

"Script for plotting functional values for all result directories"

__author__ = "Kristoffer Selim and Anders Logg"
__copyright__ = "Copyright (C) 2010 Simula Research Laboratory and %s" % __author__
__license__  = "GNU GPL Version 3 or any later version"

import os, glob, sys
from numpy import argsort, array
from pylab import *

# Get command-line parameters
cases = ("M", "e", "E", "Eh", "Ek", "Ec", "I")
if len(sys.argv) != 2 or not sys.argv[1] in cases:
    print "Usage: plot <variable>"
    print "where <variable> is one of %s" % ", ".join(cases)
    sys.exit(1)
variable = sys.argv[1]

# Set reference value
reference_value = 0.00364

def read(filename):
    return zip(*[[x for x in row.split(" ") if len(x) >0] for row in open(filename).read().split("\n") if " " in row and len(row) > 0])

def read_float(filename):
    return array([[float(x) for x in column] for column in read(filename)])

# Check all results directories
D   = []
M   = []
ETA = []
E   = []
Eh  = []
Ek  = []
Ec  = []
I   = []
L   = []
for directory in glob.glob("results-*"):
    print "Extracting values from %s" % directory

    # Check for data
    if not os.path.isfile("%s/goal_functional_final.txt" % directory):
        continue

    # Get number of dofs
    filename = "%s/num_dofs.txt" % directory
    if os.path.isfile(filename):
        d = read_float(filename)[2]
        D.append(d)

    # Get functional values
    filename = "%s/goal_functional_final.txt" % directory
    if os.path.isfile(filename):
        m = read_float(filename)[2]
        M.append(m)
        eta = abs(m - reference_value)
        ETA.append(abs(m - reference_value))

    # Get error estimates
    filename = "%s/error_estimates.txt" % directory
    if os.path.isfile(filename):
        e, eh, ek, ec = read_float(filename)[1:5]
        E.append(e)
        Eh.append(eh)
        Ek.append(ek)
        Ec.append(ec)

    # Compute efficiency index
    n = min(len(e), len(eta))
    i = e[:n] / eta[:n]
    I.append(i)

    # Get legend
    filename = "%s/application_parameters.xml" % directory
    row = [row for row in open(filename).read().split("\n") if "description" in row][0]
    l = row.split('value="')[1].split('"')[0]
    L.append(l)

    print "Found %d values" % len(d)

# Select variable to plot
X = D
if variable == "M":
    Y = M
    _title  = "Convergence of goal functional"
    _ylabel = "$\mathcal{M}(u_h)$"
    _plot   = semilogx
elif variable == "e":
    Y = ETA
    _title  = "Error in goal functional"
    _ylabel = "$\eta = |\mathcal{M}(u_h) - \mathcal{M}(u)|$"
    _plot   = loglog
elif variable == "E":
    Y = E
    _title  = "Error estimate (total)"
    _ylabel = "$E$"
    _plot   = loglog
elif variable == "Eh":
    Y = Eh
    _title  = "Space discretization error"
    _ylabel = "$E_h$"
    _plot   = loglog
elif variable == "Ek":
    Y = Ek
    _title  = "Time discretization error"
    _ylabel = "$E_k$"
    _plot   = loglog
elif variable == "Ec":
    Y = Ec
    _title  = "Computational error"
    _ylabel = "$E_c$"
    _plot   = loglog
elif variable == "I":
    Y = I
    _title  = "Efficiency index"
    _ylabel = "$\eta_h / \eta$"
    #_plot   = semilogx
    _plot   = loglog

# Sort values by legend
indices = argsort(L)
L = [L[i] for i in indices]

 # Group values
plotvals = []
for i in indices:
    x = X[i]
    y = Y[i]
    if len(y) < len(x):
        print "Warning: missing values for %s (only %d, expecting %d)" % (variable, len(y), len(x))
        x = x[:len(y)]
    plotvals.append(x)
    plotvals.append(y)

# Set fontsize for legend
rcParams.update({'legend.fontsize': 11})

# Plot functional values
max_plots = 9
for i in range((len(L) - 1) / max_plots + 1):
    figure(i)
    subplot(2, 1, 1)
    xy = plotvals[2*i*max_plots:2*(i + 1)*max_plots]
    _plot(*xy, marker='o')
    grid(True)
    xlabel("Number of dofs (in space)")
    ylabel(_ylabel)
    title(_title)
    legend(L[i*max_plots:(i + 1)*max_plots], bbox_to_anchor=(-0.1, -0.3), loc=2, borderaxespad=0)

show()
